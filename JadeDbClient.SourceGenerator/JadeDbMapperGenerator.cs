using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// Polyfill for older environments if needed
namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit { }
}

namespace JadeDbClient.SourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class JadeDbMapperGenerator : IIncrementalGenerator
    {
        private const string AttributeFullName = "JadeDbClient.Attributes.JadeDbObjectAttribute";
        private const string ColumnAttributeFullName = "JadeDbClient.Attributes.JadeDbColumnAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: AttributeFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) =>
                    {
                        if (ctx.TargetNode is not ClassDeclarationSyntax classDecl) return null;
                        if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol) return null;

                        if (!classDecl.Modifiers.Any(SyntaxKind.PartialKeyword)) return null;
                        if (typeSymbol.IsAbstract || typeSymbol.IsStatic) return null;

                        var columnAttrSymbol = ctx.SemanticModel.Compilation.GetTypeByMetadataName(ColumnAttributeFullName);

                        var props = typeSymbol.GetMembers()
                            .OfType<IPropertySymbol>()
                            .Where(p => !p.IsStatic && !p.IsIndexer)
                            .Where(p => p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal)
                            .Where(p => p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or null)
                            .Select(p =>
                            {
                                string columnName = p.Name;
                                var colAttr = p.GetAttributes().FirstOrDefault(a =>
                                    columnAttrSymbol != null && SymbolEqualityComparer.Default.Equals(a.AttributeClass, columnAttrSymbol));

                                if (colAttr?.ConstructorArguments.Length > 0 &&
                                    colAttr.ConstructorArguments[0].Value is string cn)
                                {
                                    columnName = cn;
                                }

                                return new PropertyToMap(
                                    Name: p.Name,
                                    ColumnName: columnName,
                                    TypeFullName: p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                    IsValueType: p.Type.IsValueType,
                                    IsNullable: p.NullableAnnotation == NullableAnnotation.Annotated,
                                    IsEnum: p.Type.TypeKind == TypeKind.Enum,
                                    HasPublicSetter: p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal
                                );
                            })
                            .ToImmutableArray();

                        return new ModelToMap(
                            FullName: typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                            Properties: props);
                    })
                .Where(static m => m is not null);

            context.RegisterSourceOutput(provider.Collect(), static (spc, models) =>
            {
                if (models.IsDefaultOrEmpty) return;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Data;");
                sb.AppendLine("using System.Runtime.CompilerServices;");
                sb.AppendLine("using JadeDbClient.Initialize;");
                sb.AppendLine();
                sb.AppendLine("namespace JadeDbClient.Generated;");
                sb.AppendLine();
                sb.AppendLine("[global::System.Runtime.CompilerServices.CompilerGenerated]");
                sb.AppendLine("public static class JadeDbMapperInitializer");
                sb.AppendLine("{");
                sb.AppendLine("    [ModuleInitializer]");
                sb.AppendLine("    public static void Initialize()");
                sb.AppendLine("    {");

                foreach (var model in models)
                {
                    sb.AppendLine($"        JadeDbMapperOptions.GlobalMappers[typeof({model.FullName})] = static (global::System.Data.IDataRecord reader) => new {model.FullName}");
                    sb.AppendLine("        {");

                    foreach (var prop in model.Properties)
                    {
                        string expr = GetMappingExpression(prop);
                        sb.AppendLine($"            {prop.Name} = {expr},");
                    }

                    sb.AppendLine("        };");
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                spc.AddSource("JadeDbMapperInitializer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }

        private static string GetMappingExpression(PropertyToMap p)
        {
            if (!p.HasPublicSetter) return "default!"; // or skip property

            string ord = $"reader.GetOrdinal(\"{p.ColumnName}\")";
            string dbNull = $"reader.IsDBNull({ord})";

            string baseExpr;

            if (p.IsEnum)
            {
                // Safe fallback for enums (handles int, byte, long, etc.)
                baseExpr = $"({p.TypeFullName})reader.GetValue({ord})";
            }
            else
            {
                baseExpr = p.TypeFullName switch
                {
                    "global::System.Boolean"  => $"reader.GetBoolean({ord})",
                    "global::System.Byte"     => $"reader.GetByte({ord})",
                    "global::System.Char"     => $"reader.GetChar({ord})",
                    "global::System.DateTime" => $"reader.GetDateTime({ord})",
                    "global::System.Decimal"  => $"reader.GetDecimal({ord})",
                    "global::System.Double"   => $"reader.GetDouble({ord})",
                    "global::System.Guid"     => $"reader.GetGuid({ord})",
                    "global::System.Int16"    => $"reader.GetInt16({ord})",
                    "global::System.Int32"    => $"reader.GetInt32({ord})",
                    "global::System.Int64"    => $"reader.GetInt64({ord})",
                    "global::System.Single"   => $"reader.GetFloat({ord})",
                    "global::System.String"   => $"reader.GetString({ord})",
                    _                         => $"reader.GetValue({ord}) is {{ }} v ? ({p.TypeFullName})v : default!"
                };
            }

            if (p.IsNullable || !p.IsValueType)
            {
                // Nullable value type or reference type → return null on DBNull
                return $"{dbNull} ? null : {baseExpr}";
            }

            // Non-nullable value type → no null check
            return baseExpr;
        }

        private record PropertyToMap(
            string Name,
            string ColumnName,
            string TypeFullName,
            bool IsValueType,
            bool IsNullable,
            bool IsEnum,
            bool HasPublicSetter);

        private record ModelToMap(
            string FullName,
            ImmutableArray<PropertyToMap> Properties);
    }
}