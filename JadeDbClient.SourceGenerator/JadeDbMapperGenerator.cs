using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// Polyfill for older environments if needed
namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit { }
}

namespace JadeDbClient.SourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class JadeDbMapperGenerator : IIncrementalGenerator
    {
        private const string AttributeFullName = "JadeDbClient.Attributes.JadeDbObjectAttribute";
        private const string ColumnAttributeFullName = "JadeDbClient.Attributes.JadeDbColumnAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: AttributeFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) =>
                    {
                        if (ctx.TargetNode is not ClassDeclarationSyntax classDecl) return null;
                        if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol) return null;

                        if (!classDecl.Modifiers.Any(SyntaxKind.PartialKeyword)) return null;
                        if (typeSymbol.IsAbstract || typeSymbol.IsStatic) return null;

                        var columnAttrSymbol = ctx.SemanticModel.Compilation.GetTypeByMetadataName(ColumnAttributeFullName);

                        var props = typeSymbol.GetMembers()
                            .OfType<IPropertySymbol>()
                            .Where(p => !p.IsStatic && !p.IsIndexer)
                            .Where(p => p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal)
                            .Where(p => p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or null)
                            .Select(p =>
                            {
                                string columnName = p.Name;
                                var colAttr = p.GetAttributes().FirstOrDefault(a =>
                                    columnAttrSymbol != null && SymbolEqualityComparer.Default.Equals(a.AttributeClass, columnAttrSymbol));

                                if (colAttr?.ConstructorArguments.Length > 0 &&
                                    colAttr.ConstructorArguments[0].Value is string cn)
                                {
                                    columnName = cn;
                                }

                                return new PropertyToMap(
                                    Name: p.Name,
                                    ColumnName: columnName,
                                    TypeFullName: p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                    IsValueType: p.Type.IsValueType,
                                    IsNullable: p.NullableAnnotation == NullableAnnotation.Annotated,
                                    IsEnum: p.Type.TypeKind == TypeKind.Enum,
                                    HasPublicSetter: p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal
                                );
                            })
                            .ToImmutableArray();

                        return new ModelToMap(
                            FullName: typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                            Properties: props);
                    })
                .Where(static m => m is not null);

            context.RegisterSourceOutput(provider.Collect(), static (spc, models) =>
            {
                if (models.IsDefaultOrEmpty) return;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Data;");
                sb.AppendLine("using System.Runtime.CompilerServices;");
                sb.AppendLine("using JadeDbClient.Initialize;");
                sb.AppendLine();
                sb.AppendLine("namespace JadeDbClient.Generated;");
                sb.AppendLine();
                sb.AppendLine("[global::System.Runtime.CompilerServices.CompilerGenerated]");
                sb.AppendLine("public static class JadeDbMapperInitializer");
                sb.AppendLine("{");
                sb.AppendLine("    [ModuleInitializer]");
                sb.AppendLine("    public static void Initialize()");
                sb.AppendLine("    {");

                foreach (var model in models)
                {
                    sb.AppendLine($"        JadeDbMapperOptions.GlobalMappers[typeof({model.FullName})] = static (global::System.Data.IDataRecord reader) => new {model.FullName}");
                    sb.AppendLine("        {");

                    foreach (var prop in model.Properties)
                    {
                        string? expr = GetMappingExpression(prop);
                        if (expr == null) continue;

                        sb.AppendLine($"            {prop.Name} = {expr},");
                    }

                    sb.AppendLine("        };");
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                spc.AddSource("JadeDbMapperInitializer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }

        private static string? GetMappingExpression(PropertyToMap p)
        {
            if (!p.HasPublicSetter) return null; // Skip property (recommended)

            string ord = $"reader.GetOrdinal(\"{p.ColumnName}\")";
            string dbNull = $"reader.IsDBNull({ord})";

            string baseExpr;

            if (p.IsEnum)
            {
                baseExpr = $"({p.TypeFullName})reader.GetValue({ord})";
            }
            else
            {
                baseExpr = p.TypeFullName switch
                {
                    // Existing primitives
                    "global::System.Boolean" => $"reader.GetBoolean({ord})",
                    "global::System.Byte" => $"reader.GetByte({ord})",
                    "global::System.Char" => $"reader.GetChar({ord})",
                    "global::System.DateTime" => $"reader.GetDateTime({ord})",
                    "global::System.Decimal" => $"reader.GetDecimal({ord})",
                    "global::System.Double" => $"reader.GetDouble({ord})",
                    "global::System.Guid" => $"reader.GetGuid({ord})",
                    "global::System.Int16" => $"reader.GetInt16({ord})",
                    "global::System.Int32" => $"reader.GetInt32({ord})",
                    "global::System.Int64" => $"reader.GetInt64({ord})",
                    "global::System.Single" => $"reader.GetFloat({ord})",
                    "global::System.String" => $"reader.GetString({ord})",

                    // New: DateTimeOffset
                    "global::System.DateTimeOffset" => $"reader.GetDateTimeOffset({ord})",

                    // New: TimeSpan (SQL 'time' type)
                    "global::System.TimeSpan" => $"reader.GetFieldValue<global::System.TimeSpan>({ord})", // or GetValue + cast if needed

                    // New: byte[]
                    "byte[]" => $"ReadByteArray(reader, {ord})", // custom helper

                    // New: Guid? is already covered by Guid + null check
                    // JSON: treat as string (common pattern)
                    "global::System.Text.Json.JsonElement"
                    or "global::System.Text.Json.JsonDocument"
                    or "global::Newtonsoft.Json.Linq.JToken" => $"reader.GetString({ord})", // parse later if needed

                    // Fallback for everything else (including spatial, custom types)
                    _ => $"reader.GetValue({ord}) is {{ }} v ? ({p.TypeFullName})v : default!"
                };
            }

            if (p.IsNullable || !p.IsValueType)
            {
                return $"{dbNull} ? null : {baseExpr}";
            }

            // Non-nullable value type
            if (p.IsEnum)
            {
                return $"{dbNull} ? default({p.TypeFullName}) : {baseExpr}";
            }

            // Non-nullable non-enum value type â†’ strict (throws on DBNull)
            return baseExpr;
        }

        // Add this to the generated file (inside JadeDbMapperInitializer or separate static class)
        private static byte[] ReadByteArray(global::System.Data.IDataRecord reader, int ordinal)
        {
            if (reader.IsDBNull(ordinal)) return null!; // or Array.Empty<byte>()

            const int bufferSize = 8192;
            using var ms = new global::System.IO.MemoryStream();
            byte[] buffer = new byte[bufferSize];
            long bytesRead;

            while ((bytesRead = reader.GetBytes(ordinal, ms.Length, buffer, 0, buffer.Length)) > 0)
            {
                ms.Write(buffer, 0, (int)bytesRead);
            }

            return ms.ToArray();
        }

        private record PropertyToMap(
            string Name,
            string ColumnName,
            string TypeFullName,
            bool IsValueType,
            bool IsNullable,
            bool IsEnum,
            bool HasPublicSetter);

        private record ModelToMap(
            string FullName,
            ImmutableArray<PropertyToMap> Properties);
    }
}