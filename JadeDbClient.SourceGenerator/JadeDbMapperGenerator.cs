#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// Polyfill for older environments if needed
namespace System.Runtime.CompilerServices
{
    internal static class IsExternalInit { }
}

namespace JadeDbClient.SourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class JadeDbMapperGenerator : IIncrementalGenerator
    {
        private const string AttributeFullName = "JadeDbClient.Attributes.JadeDbObjectAttribute";
        private const string ColumnAttributeFullName = "JadeDbClient.Attributes.JadeDbColumnAttribute";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: AttributeFullName,
                    predicate: static (node, _) => node is ClassDeclarationSyntax,
                    transform: static (ctx, ct) =>
                    {
                        if (ctx.TargetNode is not ClassDeclarationSyntax classDecl) return null;
                        if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol) return null;

                        if (!classDecl.Modifiers.Any(SyntaxKind.PartialKeyword)) return null;
                        if (typeSymbol.IsAbstract || typeSymbol.IsStatic) return null;

                        var columnAttrSymbol = ctx.SemanticModel.Compilation.GetTypeByMetadataName(ColumnAttributeFullName);

                        var props = GetAllPropertiesIncludingInherited(typeSymbol)
                            .Where(p => !p.IsStatic && !p.IsIndexer)
                            .Where(p => p.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal)
                            .Where(p => p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or null)
                            .Select(p =>
                            {
                                string columnName = p.Name;
                                var colAttr = p.GetAttributes().FirstOrDefault(a =>
                                    columnAttrSymbol != null && SymbolEqualityComparer.Default.Equals(a.AttributeClass, columnAttrSymbol));

                                if (colAttr?.ConstructorArguments.Length > 0 &&
                                    colAttr.ConstructorArguments[0].Value is string cn)
                                {
                                    columnName = cn;
                                }

                                return new PropertyToMap(
                                    Name: p.Name,
                                    ColumnName: columnName,
                                    TypeFullName: p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                                    IsValueType: p.Type.IsValueType,
                                    IsNullable: p.NullableAnnotation == NullableAnnotation.Annotated,
                                    IsEnum: p.Type.TypeKind == TypeKind.Enum,
                                    HasPublicSetter: p.SetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal,
                                    HasPublicGetter: p.GetMethod?.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal
                                );
                            })
                            .ToImmutableArray();

                        return new ModelToMap(
                            FullName: typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                            Properties: props);
                    })
                .Where(static m => m is not null);

            context.RegisterSourceOutput(provider.Collect(), static (spc, models) =>
            {
                if (models.IsDefaultOrEmpty) return;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Data;");
                sb.AppendLine("using System.Runtime.CompilerServices;");
                sb.AppendLine("using JadeDbClient.Initialize;");
                sb.AppendLine();
                sb.AppendLine("namespace JadeDbClient.Generated;");
                sb.AppendLine();
                sb.AppendLine("[global::System.Runtime.CompilerServices.CompilerGenerated]");
                sb.AppendLine("public static class JadeDbMapperInitializer");
                sb.AppendLine("{");
                sb.AppendLine("    [ModuleInitializer]");
                sb.AppendLine("    public static void Initialize()");
                sb.AppendLine("    {");

                foreach (var model in models)
                {
                    var settableProps = model.Properties.Where(p => p.HasPublicSetter).ToArray();

                    sb.AppendLine($"        JadeDbMapperOptions.RegisterGlobalMapper<{model.FullName}>(static (global::System.Data.IDataReader reader) =>");
                    sb.AppendLine("        {");

                    // Declare ordinal variables initialised to -1 (column absent)
                    foreach (var prop in settableProps)
                    {
                        sb.AppendLine($"            int __ord_{prop.Name} = -1;");
                    }

                    // Populate ordinals with a single pass over the reader's columns
                    sb.AppendLine("            for (int __i = 0; __i < reader.FieldCount; __i++)");
                    sb.AppendLine("            {");
                    sb.AppendLine("                var __cn = reader.GetName(__i);");
                    foreach (var prop in settableProps)
                    {
                        sb.AppendLine($"                if (string.Equals(__cn, \"{prop.ColumnName}\", global::System.StringComparison.OrdinalIgnoreCase)) {{ __ord_{prop.Name} = __i; continue; }}");
                    }
                    sb.AppendLine("            }");

                    // Build and return the mapped object
                    sb.AppendLine($"            return new {model.FullName}");
                    sb.AppendLine("            {");

                    foreach (var prop in model.Properties)
                    {
                        string? expr = GetMappingExpression(prop);
                        if (expr == null) continue;

                        // Use default! only for non-nullable reference types to suppress the
                        // nullable warning; value types and nullable types can use plain default.
                        string fallback = (!prop.IsValueType && !prop.IsNullable) ? "default!" : "default";
                        sb.AppendLine($"                {prop.Name} = __ord_{prop.Name} >= 0 ? ({expr}) : {fallback},");
                    }

                    sb.AppendLine("            };");
                    sb.AppendLine("        });");
                    sb.AppendLine();

                    // Generate bulk insert accessor for reflection-free bulk operations
                    GenerateBulkInsertAccessor(sb, model);
                }

                sb.AppendLine("    }");
                sb.AppendLine("}");

                spc.AddSource("JadeDbMapperInitializer.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }

        /// <summary>
        /// Returns all public instance properties declared on <paramref name="typeSymbol"/> and
        /// all of its base types (up to, but not including, <c>System.Object</c>).
        /// Properties declared on a derived type shadow those with the same name on a base type.
        /// </summary>
        private static IEnumerable<IPropertySymbol> GetAllPropertiesIncludingInherited(INamedTypeSymbol typeSymbol)
        {
            var seenNames = new HashSet<string>(StringComparer.Ordinal);
            var current = typeSymbol;
            while (current != null && current.SpecialType != SpecialType.System_Object)
            {
                foreach (var member in current.GetMembers().OfType<IPropertySymbol>())
                {
                    if (seenNames.Add(member.Name))
                    {
                        yield return member;
                    }
                }
                current = current.BaseType;
            }
        }

        private static void GenerateBulkInsertAccessor(StringBuilder sb, ModelToMap model)
        {
            // For bulk insert, we need properties with public getters (to read values from objects)
            var readableProps = model.Properties.Where(p => p.HasPublicGetter).ToArray();
            if (readableProps.Length == 0) return;

            sb.AppendLine($"        JadeDbMapperOptions.RegisterBulkInsertAccessor<{model.FullName}>(");
            sb.AppendLine($"            columnNames: new[] {{ {string.Join(", ", readableProps.Select(p => $"\"{p.ColumnName}\""))} }},");
            sb.AppendLine($"            accessor: ({model.FullName} model_obj) => new object?[] {{ {string.Join(", ", readableProps.Select(p => $"model_obj.{p.Name}"))} }}");
            sb.AppendLine("        );");
        }

        private static string? GetMappingExpression(PropertyToMap p)
        {
            if (!p.HasPublicSetter) return null; // Skip property (recommended)

            string ord = $"__ord_{p.Name}";
            string dbNull = $"reader.IsDBNull({ord})";

            string baseExpr;

            if (p.IsEnum)
            {
                baseExpr = $"({p.TypeFullName})reader.GetValue({ord})";
            }
            else
            {
                baseExpr = p.TypeFullName switch
                {
                    // Existing primitives
                    "global::System.Boolean" => $"reader.GetBoolean({ord})",
                    "global::System.Byte" => $"reader.GetByte({ord})",
                    "global::System.Char" => $"reader.GetChar({ord})",
                    "global::System.DateTime" => $"reader.GetDateTime({ord})",
                    "global::System.Decimal" => $"reader.GetDecimal({ord})",
                    "global::System.Double" => $"reader.GetDouble({ord})",
                    "global::System.Guid" => $"reader.GetGuid({ord})",
                    "global::System.Int16" => $"reader.GetInt16({ord})",
                    "global::System.Int32" => $"reader.GetInt32({ord})",
                    "global::System.Int64" => $"reader.GetInt64({ord})",
                    "global::System.Single" => $"reader.GetFloat({ord})",
                    "global::System.String" => $"reader.GetString({ord})",

                    // New: DateOnly (convert from DateTime returned by most DB providers)
                    "global::System.DateOnly" => $"global::System.DateOnly.FromDateTime(reader.GetDateTime({ord}))",

                    // New: DateTimeOffset
                    "global::System.DateTimeOffset" => $"reader.GetDateTimeOffset({ord})",

                    // New: TimeSpan (SQL 'time' type)
                    "global::System.TimeSpan" => $"reader.GetFieldValue<global::System.TimeSpan>({ord})", // or GetValue + cast if needed

                    // New: byte[]
                    "byte[]" => $"ReadByteArray(reader, {ord})", // custom helper

                    // New: Guid? is already covered by Guid + null check
                    // JSON: treat as string (common pattern)
                    "global::System.Text.Json.JsonElement"
                    or "global::System.Text.Json.JsonDocument"
                    or "global::Newtonsoft.Json.Linq.JToken" => $"reader.GetString({ord})", // parse later if needed

                    // Fallback for everything else (including spatial, custom types)
                    _ => $"reader.GetValue({ord}) is {{ }} v_{p.Name} ? ({p.TypeFullName})v_{p.Name} : default!"
                };
            }

            if (p.IsNullable || !p.IsValueType)
            {
                // For non-nullable reference types use default! to avoid CS8601; nullable types can use null.
                string nullExpr = (!p.IsValueType && !p.IsNullable) ? "default!" : "null";
                return $"{dbNull} ? {nullExpr} : {baseExpr}";
            }

            // Non-nullable value type
            if (p.IsEnum)
            {
                return $"{dbNull} ? default({p.TypeFullName}) : {baseExpr}";
            }

            // Non-nullable non-enum value type â†’ strict (throws on DBNull)
            return baseExpr;
        }

        // Add this to the generated file (inside JadeDbMapperInitializer or separate static class)
        private static byte[] ReadByteArray(global::System.Data.IDataRecord reader, int ordinal)
        {
            if (reader.IsDBNull(ordinal)) return null!; // or Array.Empty<byte>()

            const int bufferSize = 8192;
            using var ms = new global::System.IO.MemoryStream();
            byte[] buffer = new byte[bufferSize];
            long bytesRead;

            while ((bytesRead = reader.GetBytes(ordinal, ms.Length, buffer, 0, buffer.Length)) > 0)
            {
                ms.Write(buffer, 0, (int)bytesRead);
            }

            return ms.ToArray();
        }

        private record PropertyToMap(
            string Name,
            string ColumnName,
            string TypeFullName,
            bool IsValueType,
            bool IsNullable,
            bool IsEnum,
            bool HasPublicSetter,
            bool HasPublicGetter);

        private record ModelToMap(
            string FullName,
            ImmutableArray<PropertyToMap> Properties);
    }
}